
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JVM - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="1.jvm参数设置-xms初始堆内存 3g-xmx最大堆内存 3g-xmn年轻代内存 2g-xss每个线程的栈大小 1M-XX:MetaspaceSize 元空间初始大小-XX:MaxMetaspa,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    <meta name="twitter:image:src" content="https://bangdream.moe/img/ident.png"/>
    <meta name="twitter:creator" content="@yourtwitteridhere"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:title" content="JVM - Hexo"/>
    <meta name="twitter:description" content="1.jvm参数设置-xms初始堆内存 3g-xmx最大堆内存 3g-xmn年轻代内存 2g-xss每个线程的栈大小 1M-XX:MetaspaceSize 元空间初始大小-XX:MaxMetaspa,"/>
    <meta property="og:image" content="https://bangdream.moe/img/ident.png"/>
    <meta property="og:image:alt" content="1.jvm参数设置-xms初始堆内存 3g-xmx最大堆内存 3g-xmn年轻代内存 2g-xss每个线程的栈大小 1M-XX:MetaspaceSize 元空间初始大小-XX:MaxMetaspa,"/>
    <meta property="og:image:width" content="1200"/>
    <meta property="og:image:height" content="600"/>
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="JVM - Hexo"/>
    <meta property="og:description" content="1.jvm参数设置-xms初始堆内存 3g-xmx最大堆内存 3g-xmn年轻代内存 2g-xss每个线程的栈大小 1M-XX:MetaspaceSize 元空间初始大小-XX:MaxMetaspa,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">JVM</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">JVM</h1>
        <div class="stuff">
            <span>四月 05, 2023</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JVM%E8%AF%A6%E8%B0%88/" rel="tag">JVM详谈</a></li></ul>


        </div>
        <div class="content markdown">
            <p>1.jvm参数设置<br>-xms初始堆内存 3g<br>-xmx最大堆内存 3g<br>-xmn年轻代内存 2g<br>-xss每个线程的栈大小 1M<br>-XX:MetaspaceSize 元空间初始大小<br>-XX:MaxMetaspaceSize 元空间最大值<br>-XX:SurvivorRatio 新时代eden区和单个survivor区的比值 默认为8<br>-XX:MaxTenuringThreshold<br>设置对象在Survivor区中的最大存活次数<br>-XX:PretenureSizeThreshold<br>设置对象直接进入老年代的阈值(大对象)</p>
<p>2.new对象做了什么&#x2F;对象创建过程<br>类加载检测<br>jvm遇到new指令后，会检查该对象的符号引用是否在常量池中，如果存在那么会进行类加载检测，否则进行类加载过程<br>分配内存<br>分配内存的方法有指针碰撞 空闲列表，jvm一般采用cas+失败重试进行内存分配为了避免并发分配竞争问题，每个线程在JVM启动时都会在Eden区分配一块TLAB内存(线程本地分配缓冲)用于分配内存，如果TLAB内存不足只能在Eden区进行分配<br>初始化<br>给对象分配空间后，对空间进行赋值默认值<br>设置对象头<br>每个对象都有对象头、实例数据和对齐填充。对象头包括mardword、klass pointer、数组长度<br>执行<init>方法<br>设置完对象头后执行init方法按照预期值对内存空间进行初始化，然后执行构造方法</p>
<p>3.类的实例化顺序<br>静态变量→静态代码块→普通变量→普通代码块→构造方法<br>静态变量和静态代码块<br>在类加载到jvm初始化一次<br>普通变量和普通代码块<br>每次类对象实例化时初始化</p>
<p>4.什么是栈上分配<br>一般new出来的对象都是放在堆上的，当对象没有被引用时会被GC回收，当对象创建过多时，GC会有一定压力，所以为了避免临时对象直接分配到堆上，JVM可以通过逃逸分析，将不被外部引用的对象不进行创建，采用标量替换的方式直接分配到栈上，这样可以随着栈帧的出栈而销毁，减轻GC压力<br>逃逸分析 可以理解为 对象被return就代表逃逸<br>标量替换 可以理解为 将对象的成员变量拆出来，标识是哪个对象的</p>
<p>5.常量池的分类<br>class常量池<br>存放编译期间的字面量和符号引用<br>运行时常量池<br>在jvm运行期间，会将字符串常量池的静态数据加载到方法区<br>全局常量池<br>存放字符串的引用值<br>字符串常量池<br>用于缓存字符串<br>1)当以字符串常量的方式创建字符串，会先从常量池中查找，如果找到就返回其引用，否则在常量池中创建并返回引用<br>2)当以new的方式创建字符串，无论常量池中是否存在字符串引用，都会在堆内存中创建一个字符串对象并返回引用</p>
<p>6.判断垃圾算法<br>引用计数法<br>每个对象维护一个计数器 被引用+1 不被引用-1 但是无法解决循环依赖问题<br>可达性分析法<br>从gc root出发，通过引用对象图，标记出所有非垃圾对象，清理未被标记的对象</p>
<p>7.哪些对象可以作为gc root<br>虚拟机栈引用的对象<br>静态属性引用的对象<br>常量引用的对象<br>本地方法栈中jni引用的对象<br>持有同步锁的对象，spring bean</p>
<p>8.jvm组成部分<br>两个系统<br>类加载子系统-将字节码文件加载到jvm内存中<br>字节码执行引擎-负责gc 执行字节码文件指令和修改程序计数器的值<br>两个组件<br>运行时数据区(即jvm内存)<br>本地接口(JNI-Java native interface)</p>
<p>9.jvm类加载过程<br>分为7个阶段<br>加载 链接(验证 准备 解析) 初始化 使用 卸载<br>加载<br>将字节码文件加载到运行时的数据区的方法区(即jvm内存的方法区)<br>验证<br>对字节码进行校验，包括文件格式验证、元数据验证、字节码验证和符号引用验证<br>如魔数、主次版本号<br>准备<br>将类中的静态变量分配空间并设置默认值<br>解析<br>将符号引用变为直接引用<br>符号引用在字节码文件中的以字符串的形式表示的<br>直接引用是指向内存的实际对象或函数的指针<br>初始化<br>执行类构造器方法，执行完成后类被初始化为可执行的状态，类的静态变量被正确赋值及静态代码块执行完毕</p>
<p>10.哪些情况下类被卸载<br>垃圾收集时，如果类的Class对象没有被任何引用指向，即无法通过反射访问该类。则类会被垃圾收集器回收，导致类被卸载<br>程序退出时，Java虚拟机会退出卸载所有类<br>当类的加载器被回收<br>当前类的所有对象实例都被回收</p>
<p>11.Java oom类型<br>java heap space对象过多，过大或堆内存泄露导致的内存不足<br>unable to create native thread 创建过多线程<br>PermGen space &#x2F; Metaspace 存储类的字节码和字符串常量池的永生 代内存满了 &#x2F; 类数量加载过多或类信息  占用空间过多<br>Direct buffer memory 使用Java的nio(非阻塞I&#x2F;O)直接内存并  且超过–Xx:MaxDirectMemory参数设定的最大值<br>gc overhead limit exceeded jvm花费大量时间进行垃圾回收且回收  空间小  垃圾回收频繁 无法解决内存问题</p>
<p>stackoverflow栈溢出是线程栈空间不足不会导致oom，发生在函数递归调用过深或局部变量占用太大超过栈的容量限制</p>
<p>12.gc(garbage collection)分为<br>新生代gcminor gc<br>   新创建的对象加入时，新时代空间不足 触发新时代gc<br>老年代gcmajor gc<br>   经过gc后仍存活的对象进入老年代导致老年代空间不足触发老年代gc<br>全局gcfull gc<br>   永久代空间不足 手动触发gc</p>
<p>13.jvm区域划分<br>堆 元空间(方法区) 本地方法区 虚拟机栈 程序计数器<br>堆分为新时代和老年代<br>线程共享的区域:堆 元空间<br>线程私有的区域:本地方法区 虚拟机栈 程序计数器<br>堆分为新生代和老年代，新手代分为 eden(伊甸区)和s0 s1(两个存活区)，占比为8:1:1</p>
<p>14.垃圾回收器有哪些<br>1)单线程&#x2F;串行回收器<br>serial回收器<br>serial old回收器<br>2)多线程&#x2F;并行回收器<br>parallel<br>parallel old<br>parnew与cms搭配使用<br>3)多线程&#x2F;响应时间优先的并发回收器<br>cms(concurrent mark sweep)<br>g1(garbage–first)</p>
<p>15.cms和g1特点<br>CMS特点(jdk1.5)<br>并发收集 低停顿<br>避免老年代出现长时间卡顿(stw)<br>工作流程<br>   初始标记 并发标记 并发预清理<br>   重新标记 并发清除 并发重置<br>   初始标记和重新标记需要stw<br>无法清理浮动垃圾<br>   并发标记和并发清理阶段，用户线程继续运行会有新的垃圾对象产生，这一部分垃圾对象是在标记过程结束后产生的CMS无法在当次收集中处理掉它们，需要留到下一次垃圾收集时再清理掉,这一部分垃圾称为“浮动垃圾”<br>使用标记清除算法，会产生大量空间碎片<br>并发模式失败(concurrent mode failure)<br> 1)老年代空间不足<br>   cms在并发标记过程在发现大量对象需要晋升到老年代且老年代空间不足以容纳这些对象时会触发cmf并发阶段未完成<br> 2)cms没能在并发阶段内完成预取工作，   为了防止oom 需要进行full gc会stw， 无法进行并行清理<br> 3)由于在垃圾回收阶段用户线程还在并发 运行，那就还需要预留足够的内存空间 提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进<br>   行回收，必须预留一部分空间供并发回收时的程序运行使用。默 认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值通过-XXCMSInitiating<br>   OccupancyFraction 参数来设置。</p>
<p>16.cms在并发标记阶段的多标和漏标<br>标的是非垃圾对象<br>多标(并发标记阶段)<br>多标 就是本应该是垃圾对象，但是由于用户线程还在运行，对象间的引用关系可能发生变化，所以没来及去清除存活标记<br>漏标(并发标记 重新标记阶段)<br>漏标就是新来的对象引用了GC Root链上的对象，但是由于用户线程还在运行，没来得及标记为非垃圾，被GC误清除</p>
<p>17.cms产生的内存碎片<br>使用参数-xx:+UseCMSCompactAtFullCollection，让cms在执行full gc   时进行内存碎片整理<br>设置-xx:CMSFullGCsBeforeCompaction&#x3D;n 参数让cms在执行n次  不带压缩的gc后进行一次带压缩整理的full gc<br>当内存碎片严重到cms无法管理时，采用serial old执行标记 整理算法</p>
<p>18.解决cms漏标问题<br>三色标记法<br>写屏障<br>增加重新标记阶段的暂停时间<br>调整cms触发的阈值</p>
<p>19.cms三色标记<br>黑色<br>所有引用扫描过<br>白色<br>未被访问过<br>灰色<br>访问过，但至少一个对象的引用没有被扫描过</p>
<p>20.cms三色标记法的作用<br>用来解决漏标问题<br>分为增量更新和原始快照<br>增量更新是通过记录下黑色对象新增的白色对象引用关系，将黑色对象回退到灰色对象，重新深度扫描一次，一般用于重新标记阶段<br>原始快照是通过记录下灰色对象删除的白色对象的引用关系，在后续的并发标记或重新标记阶段可能会被重新考虑，以灰色对象为根简单扫描一下确保不会漏标，将白色对象标记为黑色对象，当作浮动垃圾处理，等待下一轮Gc</p>
<p>21.G1特点(jdk1.7)<br>分代收集<br>   将堆划分成多个大小相等的独立 Regi<br>   on区域(2048个)<br>并行与并发<br> 使用多线程进行垃圾回收并尽量减少stw<br> 的停顿时间，其他用户线程进行运行<br>空间整合<br>   从整体看，基于标记-整理算法<br>   从局部看，基于标记－复制算法<br>可预测的停顿<br>   G1跟踪各个Region的回收获得的空间<br>   大小和回收所需要的经验值，维护一个<br>   优先列表<br>运行流程<br>   初始标记 并发标记 最终标记 筛选回收<br>   初始标记 和 CMS的初始标记 一样<br>   并发标记 和 CMS的并发标记 一样<br>   最终标记 和 CMS的重新标记 一样，但<br>   是这里对于 漏标 的对象采用 原始快照<br>   的方式进行处理<br>使用humogous区存放大对象<br>如果humogous存放不下那么会使用多个region区进行存放<br>筛选回收<br>stw时对未标记的region进行清理，根据每个region区域回收价值和成本进行排序<br>根据用户预期停顿时间来选择合适的回收方式，不会回收所有垃圾对象，考虑到预期停顿时间，只会回收接近预取停顿时间的region，其余region等待下一次gc</p>
<p>22.jdk8之后出现的gc<br>epsilon(jdk11)<br>1)它是一个“被动”的收集器，不会执行任何实际的垃圾收集工作，而是当应用程序请求进行垃圾收集时，直接退出程序。它只负责分配内存，并不回收内存。当堆内存耗尽之后，JVM 直接因为 OutOf<br>Memory而终止Epsilon的主要用途是用于性能测试和故障排查，帮助开发者确定应用程序的垃圾收集开销是否过大。<br>2)适合运行时间很短的程序，比如命令行程序，定期执行的简单任务<br>3)对延迟和吞吐量很敏感的程序。回收垃圾的操作会带来延迟，Epsilon 完全避免了这些延迟<br>zgc(jdk11)<br>ZGC（Z Garbage Collector）是一款低延迟垃圾收集器，其设计目标是实现可预测的、小于10毫秒的停顿时间。ZGC采用了基于颜色的指针追踪技术，以及并发处理等方式，从而实现了低延迟和高吞吐量的平衡。</p>
<p>23.垃圾收集器的核心指标，设计者追求什么<br>吞吐量<br>暂停时间<br>内存占用<br>追求在延迟可控的情况下，获得尽可能高的吞吐量，追求全功能收集器</p>
<p>25.什么是STW<br>STW 就是stop the world，会暂停所有用户线程来进行GC，对于暂停的时间与垃圾收集器有关<br>年轻代的Minor GC(Young GC) 几乎无感觉<br>老年代的Full GC可能会感觉到卡顿一下</p>
<p>26.为什么要进行STW<br>STW 主要是为了更好的维护引用对象图来进行GC，如果不进行STW，用户线程还在进行着，可能一些对象还没来得及被标记就被GC了，这个是比较严重的问题</p>
<p>27.区分并发与并行的区别：<br>并行清理只是一个概念，是指多个垃圾<br>   回收线程同时运行，来清理垃圾，此时<br>   没有任何用户线程处于工作状态<br>而并发清理是只有一个垃圾回收线程运<br>   行，其他用户线程依然处于工作状态，<br>   并会源源不断地产生浮动垃圾，CMS<br>   中的就是并发清理</p>
<p>28.jvm调优</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
