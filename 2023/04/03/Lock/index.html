
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>锁 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="1.什么是cas(比较和交换)用于实现乐观锁CAS 涉及到三个操作数：V：要更新的变量值(Var)E：预期值(Expected)N：拟写入的新值(New)当且仅当 V 的值等于 E 时，CAS 通过,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    <meta name="twitter:image:src" content="https://bangdream.moe/img/ident.png"/>
    <meta name="twitter:creator" content="@yourtwitteridhere"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:title" content="锁 - Hexo"/>
    <meta name="twitter:description" content="1.什么是cas(比较和交换)用于实现乐观锁CAS 涉及到三个操作数：V：要更新的变量值(Var)E：预期值(Expected)N：拟写入的新值(New)当且仅当 V 的值等于 E 时，CAS 通过,"/>
    <meta property="og:image" content="https://bangdream.moe/img/ident.png"/>
    <meta property="og:image:alt" content="1.什么是cas(比较和交换)用于实现乐观锁CAS 涉及到三个操作数：V：要更新的变量值(Var)E：预期值(Expected)N：拟写入的新值(New)当且仅当 V 的值等于 E 时，CAS 通过,"/>
    <meta property="og:image:width" content="1200"/>
    <meta property="og:image:height" content="600"/>
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="锁 - Hexo"/>
    <meta property="og:description" content="1.什么是cas(比较和交换)用于实现乐观锁CAS 涉及到三个操作数：V：要更新的变量值(Var)E：预期值(Expected)N：拟写入的新值(New)当且仅当 V 的值等于 E 时，CAS 通过,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">锁</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">锁</h1>
        <div class="stuff">
            <span>四月 03, 2023</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E9%94%81%E7%9B%B8%E5%85%B3/" rel="tag">锁相关</a></li></ul>


        </div>
        <div class="content markdown">
            <p>1.什么是cas(比较和交换)<br>用于实现乐观锁<br>CAS 涉及到三个操作数：<br>V：要更新的变量值(Var)<br>E：预期值(Expected)<br>N：拟写入的新值(New)<br>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则是前线程放弃更新。<br>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。<br>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。<br>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</p>
<p>2.cas存在的ABA问题<br>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。<br>ABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决ABA问题的,其compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</p>
<p>3.volatile<br>volatile保证变量的可见性，当变量修饰为volatile时，该变量是共享且不稳定的，每次读取从内存中读取<br>volatile禁止指令重排，在对变量进行读写操作时，会插入特定的内存屏障来禁止指令重排，确保不同线程操作volatile时的有序性</p>
<p>4.juc的lock<br>Lock是接口，reentrantlock是实现类<br>reentrankReadWritelock读写锁实现了readwritelock接口<br>lock()方法<br>获取锁 如果锁被其他线程占有 则当前线程进入阻塞状态直到锁变为可用<br>lockInterruptibly()方法<br>与lock()方法一样是阻塞获取锁，但是在等待锁时可以响应中断请求，一旦线程被中断，会抛出InterruptedException<br>trylock()方法<br>尝试获取锁，如果可用返回true 否则立刻返回false，也可以在添加等待时间的参数和类型<br>unlock()方法<br> 释放锁<br>new Condition()<br>创建一个condition对象，用于线程间的的条件等待,await() signal() signalall()类似object类的wait()notify()notifyall()<br>await()方法还可以添加时间参数和类型<br>在这段时间内如果线程没有被唤醒，那么会被返回尝试重新获取锁</p>
<p>5.lock和synchronized的区别<br>synchronized是Java语言的关键字Lock是一个接口。<br>synchronized不需要用户去手动释放锁，发生异常或者线程结束时自动释放锁;Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。<br>lock可以配置公平策略,实现线程按照先后顺序获取锁。<br>提供了trylock方法 可以试图获取锁，获取到或获取不到时，返回不同的返回值 让程序可以灵活处理。<br>lock()和unlock()可以在不同的方法中执行,可以实现同一个线程在上一个方法中lock()在后续的其他方法中unlock(),比syncronized灵活的多。</p>
<p>6.AQS(AbstractQueueSynchornizer)<br>抽象队列同步器，是一个抽象类<br>为构建锁和同步器提供了一些通用功能实现<br>ReentrantLock,Semaphore,<br>ReentrantReadWriteLock,<br>SynchronousQueue是基于 AQS实现的</p>
<p>7.AQS原理<br>1)如果被请求的共享资源空闲，则将请求资源的线程设置为有效工作线程，并将共享资源设置为锁定状态<br>2)如果请求的共享资源被占用，需要一套线程阻塞等待及被唤醒时锁分配的机制，该机制基于AQS的CLH锁队列实现，将暂时获取不到锁的线程加入队列<br>3)AQS使用int变量state来表示线程的同步状态，state变量使用volatile修饰<br>一个线程获取到了锁那么state变量+1，线程可以重复获取锁，state每次获取+1<br>表示重入次数，释放时需要释放state次</p>
<p>8.CLH队列<br>1)CLH队列是一个虚拟双向队列，即不存在实例只有结点的关联关系。<br>2.)AQS将每个请求资源的线程封装成一个CLH锁队列的一个结点来实现锁的分配<br>一个结点代表一个线程，保存线程的引用(thread)、在队列在的状态waitStatus，<br>前驱结点prev、后继结点next</p>
<p>9.synchronized使用<br>·synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；<br>·synchronized 关键字加到实例方法上是给对象实例上锁；<br>·尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能。</p>
<p>构造方法不能使用synchronized 因为构造方法是线程安全的</p>
<p>10.synchronized底层原理<br>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。<br>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。<br>对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。<br>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。<br>不过两者的本质都是对对象监视器 monitor 的获取。</p>
<p>11.jdk1.6后synchronized的优化<br>jdk1.6前synchronized为重量级锁<br>jdk1.6后synchronized引入了自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁 轻量级锁来减少锁操作的开销<br>jdk1.8后废弃偏向锁</p>
<p>12.锁升级<br>锁升级的过程具体如下：<br>1)无锁状态：初始时，没有任何线程拥有锁，所有线程都能访问资源，但仅当资源未被修改时才能继续执行。通常使用CAS或者添加版本号操作来尝试更新资源，若失败则重试直到成功。(乐观锁)<br>2)偏向锁状态：当一个线程多次访问同步代码块且没有其他线程竞争时，JVM会认为这个锁可以被该线程”偏向”。<br>3)轻量级锁状态：如果一个线程尝试获取一个已被其他线程持有偏向锁的对象时，偏向锁会被撤销，升级为轻量级锁。<br>4)重量级锁状态：当有多个线程竞争同一个锁时，轻量级锁会升级为重量级锁。</p>
<p>13.线程如何确定是否拿到锁?锁信息具体放在哪<br>·锁是一种同步机制，用于确保同一时间只有一个线程访问共享资源<br>使用synchronized关键字，Java每个对象都有与之关联的监视器monitor，当一个线程尝试获取某个对象的锁时，jvm会在对象头记录锁的状态和锁的持有线程id<br>·锁信息放在对象头的mark word<br>1)通过thread类的holdslock()方法<br>2)ReentrantLock的isHeldByCurrent方法来判断当前线程是否拥有锁<br>3)object类的wait()和notify方法 如果没有锁则会抛出异常IllegalMonitorStateException</p>
<p>14.可重入锁<br>synchronized和reentranklock两者都是可重入锁(递归锁)，Lock类也是可重入锁，可重入锁指的是当前线程已经获取锁但未释放而再次获取锁时可以成功获取，如果是不可重入锁的话再次获取会造成死锁</p>
<p>15.synchronized和reentranklock区别<br>1)锁类型<br>synchronized和reentranklock都是可重入锁和非公平锁，reentranklock通过构造方法传入参数true可以是公平锁，公平锁是指等待时间最长的线程优先获取锁<br>2)实现方式<br>synchronized依赖与jvm实现<br>reentranklock依赖于jdk实现的，即api层面，需要lock()和unlock()搭配try finally语句来完成<br>3)加锁 释放锁方式<br>synchronized是自动加锁和释放锁<br>reentranklock需要手动lock加锁和unlock释放锁并搭配try finally语句来完成<br>4)功能不同<br>reentranklock相比synchronized增加了一些功能<br>·可中断的等待锁<br> lock.lockInterruptibly<br>·超时等待锁<br>线程尝试获取锁，等待一段时间后放弃<br>·选择性通知<br>通过引入condition接口实现，多个condition绑定多个线程并通过signal()方法唤醒<br>5)修饰对象不同<br>synchronized修饰代码块 方法 类<br>reentranklock只能修饰代码块</p>
<p>16.reentranklock引入的condition接口<br>condition接口提供了await()阻塞和signal()唤醒 signalAll()替代object类的wait() notify() notifyAll()</p>
<p>private Lock lock &#x3D; newReentrantLock();<br>Condition condition&#x3D;lock.newCondition(); &#x2F;&#x2F;创建 Condition<br>可以创建多个condition绑定多个线程，每个线程调用所绑定的方法，condition实现阻塞和唤醒就可以控制线程的状态，进而让多个线程之间来回切换，实现多线程的通讯协作功能。<br>注意：调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用</p>
<p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
