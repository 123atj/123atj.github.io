
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>线程池 - 艾丽莎的个人小屋</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="                                                                                                   ,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="艾丽莎的个人小屋" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    <meta name="twitter:image:src" content="https://bangdream.moe/img/ident.png"/>
    <meta name="twitter:creator" content="@yourtwitteridhere"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:title" content="线程池 - 艾丽莎的个人小屋"/>
    <meta name="twitter:description" content="                                                                                                   ,"/>
    <meta property="og:image" content="https://bangdream.moe/img/ident.png"/>
    <meta property="og:image:alt" content="                                                                                                   ,"/>
    <meta property="og:image:width" content="1200"/>
    <meta property="og:image:height" content="600"/>
    <meta property="og:site_name" content="艾丽莎的个人小屋"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="线程池 - 艾丽莎的个人小屋"/>
    <meta property="og:description" content="                                                                                                   ,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">艾丽莎的个人小屋</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">线程池</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">线程池</h1>
        <div class="stuff">
            <span>七月 05, 2023</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">线程池的使用</a></li></ul>


        </div>
        <div class="content markdown">
            <pre><code>                                                                                                                                                                                                                        ..                 
</code></pre>
<h4 id="线程池及核心参数"><a href="#线程池及核心参数" class="headerlink" title="线程池及核心参数"></a>线程池及核心参数</h4><p>线程池就是管理一系列线程的资源池，为了减少每次获取资源的消耗，提高对资源的利用率、响应速度及线程的可管理性，线程池还维护一些基本统计信息，如已完成任务的数量</p>
<h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><p><strong>corePoolSize：</strong>任务队列中的任务未达到队列容量时， 最大可以同时运行的线程数量</p>
<p><strong>maximumPoolSize：</strong>任务队列中存放的任务达到队列容量 时，当前可以同时运行的线程数量变为最大线程数</p>
<p><strong>keepAliveTime：</strong>线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线 程一视同仁，直到线程池中线程的数量等于corePoolSize,回收过程才会停止</p>
<p><strong>Unit：</strong>设置存活时间单位 (TimeUnit.Seconds)  分 (Time.Minutes)</p>
<p><strong>任务队列 workQueue：</strong>新任务来的时候会先判断当前运行的线   程数量是否达到核心线程数，如果达到 的话，新任务就会被存放在队列中 </p>
<p><strong>线程工厂 threadFactory</strong></p>
<p><strong>饱和策略 rejectExecutorHandler</strong> </p>
<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>RejectExecutorHandler handler&#x3D;new ThreadPoolExecutor.AbortPolicy()<br><strong>AbortPolicy：</strong>默认策略，当线程池到达最大容量抛出rejectExecutorException</p>
<p><strong>CallerRunsPolicy：</strong>当线程池满时会将任务交给调用者执行，允许任务提交者执行任务</p>
<p><strong>DiscardOldestPolicy：</strong>当线程池满时丢弃队列最老的任务请求，然后尝试重新提交当前任务</p>
<p><strong>DiscardPolicy：</strong>丢弃队列中无法执行的任务，不会给出通知和抛出异常</p>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><strong>ArrayBlockingQueue</strong></h5><p>基于环形数组的有界阻塞队列，按FIFO存储元素，队列满时阻塞写操作，空时阻塞读操作，无需指定初始容量</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><strong>LinkedBlockingQueue</strong></h5><p>基于链表实现的可选有界或无界阻塞队列  无固定容量限制，队列满时阻塞写操作，空时阻塞读操作</p>
<h5 id="SynchronousQueue同步队列"><a href="#SynchronousQueue同步队列" class="headerlink" title="SynchronousQueue同步队列"></a><strong>SynchronousQueue同步队列</strong></h5><p>没有容量 不存储元素 每次插入操作必须等待另一个线程的移除操作，可用于线程间的数据交换</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h5><p>基于优先队列实现的延迟阻塞队列，可以存储实现delayed接口的元素，每个元素都有过期时间，元素过期后才能从队列取出</p>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h5><p>具有优先级的无界阻塞队列,可以按照元素优先级排序,优先级通过Comparator参数实现。</p>
<h4 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h4><p>有任务到达时，创建核心线程去执行，如果任务数量超过核心线程数，加入阻塞队列，队列满了创建非核心线程，超过最大线程数采取拒绝策略</p>
<h4 id="创建线程池的方式及参数"><a href="#创建线程池的方式及参数" class="headerlink" title="创建线程池的方式及参数"></a>创建线程池的方式及参数</h4><h5 id="1-ThreadPoolExecutor构造函数来创建"><a href="#1-ThreadPoolExecutor构造函数来创建" class="headerlink" title="1)ThreadPoolExecutor构造函数来创建"></a><strong>1)ThreadPoolExecutor构造函数来创建</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize,</span><br><span class="line">maximumPoolSize, keepAliveTime,unit,workQueue,threadFactory,handler)</span><br></pre></td></tr></table></figure>

<p>核心参数corePoolSize maximumPoolSize  workQueue是必须的</p>
<h5 id="2-通过-Executor-框架的工具Executors来创建"><a href="#2-通过-Executor-框架的工具Executors来创建" class="headerlink" title="2)通过 Executor 框架的工具Executors来创建"></a><strong>2)通过 Executor 框架的工具Executors来创建</strong></h5><h4 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h4><h5 id="1-继承thread类-重写run方法"><a href="#1-继承thread类-重写run方法" class="headerlink" title="1)继承thread类 重写run方法"></a><strong>1)继承thread类 重写run方法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    // 线程要执行的任务</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyThread mt = new MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-实现runnable接口-重写run方法"><a href="#2-实现runnable接口-重写run方法" class="headerlink" title="2)实现runnable接口 重写run方法"></a><strong>2)实现runnable接口 重写run方法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    // 线程要执行的任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyRunnable myRunnable = new MyRunnable();</span><br><span class="line">    Thread thread = new Thread(myRunnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-实现callback接口和futuretask-重写call方法"><a href="#3-实现callback接口和futuretask-重写call方法" class="headerlink" title="3)实现callback接口和futuretask 重写call方法"></a><strong>3)实现callback接口和futuretask 重写call方法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws exception &#123;</span><br><span class="line">    // 线程要执行的任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    MyCallable mc = new MyCallable();</span><br><span class="line">    FutureTask ft = new FutureTask(mc)</span><br><span class="line">    ExecutorService es = Executors.new</span><br><span class="line">    SingleThreadExecutor();</span><br><span class="line">    es.submit(ft);</span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-使用线程池创建"><a href="#4-使用线程池创建" class="headerlink" title="4)使用线程池创建"></a><strong>4)使用线程池创建</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newFixedThreadPool(5);</span><br><span class="line">    es.submit(()-&gt; &#123;</span><br><span class="line">    线程要执行的任务</span><br><span class="line">    &#125;);</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></table></figure>

<h4 id="核心线程满了之后先加入阻塞队列而不是创建新的线程"><a href="#核心线程满了之后先加入阻塞队列而不是创建新的线程" class="headerlink" title="核心线程满了之后先加入阻塞队列而不是创建新的线程"></a>核心线程满了之后先加入阻塞队列而不是创建新的线程</h4><ul>
<li>线程池创建线程需要获取mainlock这个全局锁，会影响并发效率，所以使用阻塞队列把创建核心线程与创建最大线程隔离开来，起一个缓冲的作用。在执行execute()方法时尽可能的避免获取全局锁</li>
<li>阻塞队列可以保存任务，当队列没有任务时阻塞获取任务的线程、使其进入wait状态，释放CPU资源</li>
<li>阻塞队列自带阻塞和唤醒功能，不需要额外的处理，无任务时线程池利用阻塞队列的take方法挂起，从而保证核心线程的存活，不至于一直占用CPU资源</li>
</ul>
<h4 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h4><p><strong>singleThreadPool：</strong>只有一个核心线程，所有任务都在一个线程上顺序执行 </p>
<p><strong>fixedThreadPool：</strong>核心线程与最大线程数一样 ，超过最大线程数会将任务放在任务队列中  </p>
<p><strong>cachedThreadPool：</strong>核心线程数为0 最大线程数为int最大值 空闲线程在60s后回收</p>
<p><strong>scheduleThreadPool：</strong>核心线程数固定，支持定时或周期性执行任务</p>
<p><strong>workStealingPool(jdk8)：</strong> 动态线程池，内部使用forkjoinPool实现，利用分层工作窃取算法处理任务，每个工作线程维护自己的本地队列，同时可以从其他线程的队列中窃取任务，线程数根据cpu核心数调整</p>
<h4 id="不使用内置线程池"><a href="#不使用内置线程池" class="headerlink" title="不使用内置线程池"></a>不使用内置线程池</h4><ul>
<li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池,有可能会造成系统创建大量同类线程而导致消耗完内存或者过度上下文切换</li>
<li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor</li>
</ul>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<h4 id="线程数设置"><a href="#线程数设置" class="headerlink" title="线程数设置"></a>线程数设置</h4><p>N是CPU核心数</p>
<ul>
<li>CPU 密集型任务(N+1)：利用CPU 计算能力的任务比如在内存中对大量数据进行排序 复杂算法</li>
<li>I&#x2F;O 密集型任务(2N+1)：涉及到网络传输&#x2F;文件读取下载&#x2F;数据库交互 系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程</li>
<li>比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断或其它原因导致的任务暂停而带来的影响</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
