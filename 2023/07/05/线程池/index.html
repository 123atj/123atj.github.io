
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>线程池 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="​                      1.自动调用run()和手动调用run()调用 start() 方法方可启动线程并使线程进入就绪状态，自动调用run()方法会以多线程的方式执行直接执行,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    <meta name="twitter:image:src" content="https://bangdream.moe/img/ident.png"/>
    <meta name="twitter:creator" content="@yourtwitteridhere"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:title" content="线程池 - Hexo"/>
    <meta name="twitter:description" content="​                      1.自动调用run()和手动调用run()调用 start() 方法方可启动线程并使线程进入就绪状态，自动调用run()方法会以多线程的方式执行直接执行,"/>
    <meta property="og:image" content="https://bangdream.moe/img/ident.png"/>
    <meta property="og:image:alt" content="​                      1.自动调用run()和手动调用run()调用 start() 方法方可启动线程并使线程进入就绪状态，自动调用run()方法会以多线程的方式执行直接执行,"/>
    <meta property="og:image:width" content="1200"/>
    <meta property="og:image:height" content="600"/>
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="线程池 - Hexo"/>
    <meta property="og:description" content="​                      1.自动调用run()和手动调用run()调用 start() 方法方可启动线程并使线程进入就绪状态，自动调用run()方法会以多线程的方式执行直接执行,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">线程池</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">线程池</h1>
        <div class="stuff">
            <span>七月 05, 2023</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="tag">线程池的使用</a></li></ul>


        </div>
        <div class="content markdown">
            <p>​                      <img src="/2023/07/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0/blog/source\img\2.jpg" alt="2"><br>1.自动调用run()和手动调用run()<br>调用 start() 方法方可启动线程并使线程进入就绪状态，自动调用run()方法会以多线程的方式执行<br>直接执行 run() 方法的话不会以多线程的方式执行，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行</p>
<p>2.threadlocal<br>threadlocal是用于保存线程变量的副本，应用于缓存用户信息、连接。通过保证每个线程变量隔离来保证线程安全<br>内部维护一个以threadlocalmap为key，线程变量副本为value的map，key是弱引用，在gc时会被回收，而value是强引用，不会被回收，需要手动进行清理，随着value的增多可能会导致内存泄露(程序申请空间但却无法释放)<br>threadlocal只保证线程内部通信<br>inheritableThreadlocal可以保证父子线程之间的通信，父线程在子线程创建时会拷贝一份线程变量副本给子线程，但是在线程池下无法适用，因为线程池的线程可以复用，没有新建过程<br>transmittableThreadlocal可以保证线程池中无论线程是否新建都会在调用时抓取父线程的变量副本给子线程<br>threadlocal维护的map解决哈希冲突采用的是线性探测，在面对大量线程绑定数据时性能较低，因此netty引入了fast<br>Threadlocal，通过开辟更大的数组保存索引，采用空间换时间的方式，且在执行任务完成后会对value进行清理防止内存泄露</p>
<p>3.线程池及核心参数<br>线程池就是管理一系列线程的资源池，为了减少每次获取资源的消耗，提高对资源的利用率、响应速度及线程的可管理性<br>线程池还维护一些基本统计信息，如已完成任务的数量</p>
<p>4.线程池参数<br>corePoolSize<br>任务队列中的任务未达到队列容量时， 最大可以同时运行的线程数量<br>maximumPoolSize<br>任务队列中存放的任务达到队列容量 时，当前可以同时运行的线程数量变为最大线程数<br>keepAliveTime<br>线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线 程一视同仁，直到线程池中线程的数量等于corePoolSize,回收过程才会停止<br>Unit<br>设置存活时间单位 (TimeUnit.Seconds)  分 (Time.Minutes)<br>任务队列 workQueue<br>新任务来的时候会先判断当前运行的线   程数量是否达到核心线程数，如果达到 的话，新任务就会被存放在队列中。<br>BlockingQueue<Runable> work &#x3D;new LinkedBlockingQueue&lt;&gt;()；<br>线程工厂 threadFactory<br>饱和策略 rejectExecutorHandler </Runable></p>
<p>5.饱和策略<br>RejectExecutorHandler handler&#x3D;new ThreadPoolExecutor.AbortPolicy()<br>AbortPolicy<br>默认策略，当线程池到达最大容量抛出rejectExecutorException<br>CallerRunsPolicy<br>当线程池满时会将任务交给调用者执行，允许任务提交者执行任务<br>DiscardOldestPolicy<br>当线程池满时丢弃队列最老的任务请求，然后尝试重新提交当前任务<br>DiscardPolicy<br>丢弃队列中无法执行的任务，不会给出通知和抛出异常</p>
<p>6.阻塞队列<br>ArrayBlockingQueue<br>基于环形数组的有界阻塞队列，按FIFO存储元素，队列满时阻塞写操作，空时阻塞读操作，无需指定初始容量<br>LinkedBlockingQueue<br>基于链表实现的可选有界或无界阻塞队列<br>无固定容量限制，队列满时阻塞写操作，空时阻塞读操作<br>SynchronousQueue同步队列<br>没有容量 不存储元素 每次插入操作必须等待另一个线程的移除操作，可用于线程间的数据交换<br>DelayQueue<br>基于优先队列实现的延迟阻塞队列，可以存储实现delayed接口的元素，每个元素都有过期时间，元素过期后才能从队列取出<br>PriorityBlockingQueue<br>具有优先级的无界阻塞队列,可以按照元素优先级排序,优先级通过Comparator<br>参数实现。</p>
<p>7.创建线程池的方式及参数<br>–代码方式<br>1)ThreadPoolExecutor构造函数来创建<br>ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory,handler)<br>corePoolSize maximumPoolSize<br>workQueue是必须的<br>2)通过 Executor 框架的工具Executors<br>来创建<br>FixedThreadPool:固定线程数量n的线程池<br>executorService es &#x3D; Executors.newFixedThreadPool(n)；<br>singleThreadExecutor:只有一个线程的线程池，若任务数多于1个则添加到任务队列中<br>cachedThreadPool:返回一个根据实际情况调整线程数量的线程池，超过默认时间60s没有新任务线程超时自动销毁<br>scheduleThreadPool:返回在给定的延迟后运行任务或定期执行任务的线程池</p>
<p>–配置文件</p>
<p>8.线程创建方式<br>1)继承thread类 重写run方法<br>class MyThread extends Thread {<br>    @Override<br>    public void run() {<br>    &#x2F;&#x2F; 线程要执行的任务<br>    }<br>}<br>public static void main(String[] args){<br>    MyThread mt &#x3D; new MyThread();<br>    mt.start();<br>}</p>
<p>2)实现runnable接口 重写run方法<br>class MyRunnable implements Runnable {<br>    @Override<br>    public void run() {<br>    &#x2F;&#x2F; 线程要执行的任务<br>    }<br>}<br>public static void main(String[] args){<br>    MyRunnable myRunnable &#x3D; new MyRunnable();<br>    Thread thread &#x3D; new Thread(myRunnable);<br>    thread.start();<br>}</p>
<p>3)实现callback接口和futuretask 重写call方法<br>class MyCallable implements Callable<Integer> {<br>    @Override<br>    public Integer call() throws exception {<br>    &#x2F;&#x2F; 线程要执行的任务<br>    }<br>}<br>public static void main(String[] args){<br>    MyCallable mc &#x3D; new MyCallable();<br>    FutureTask ft &#x3D; new FutureTask(mc)<br>    ExecutorService es &#x3D; Executors.new<br>    SingleThreadExecutor();<br>    es.submit(ft);<br>    es.shutdown();<br>}</Integer></p>
<p>4)使用线程池创建<br>ExecutorService es &#x3D; Executors.newFixedThreadPool(5);<br>    es.submit(()-&gt; {<br>    线程要执行的任务<br>    });<br>es.shutdown();</p>
<p>9.为什么核心线程满了之后总是先加入阻塞队列而不是加入总线程或创建线程<br>线程池创建线程需要获取mainlock这个全局锁，会影响并发效率，所以使用阻塞队列把创建核心线程与创建最大线程隔离开来，起一个缓冲的作用。在执行execute()方法时尽可能的避免获取全局锁<br>阻塞队列可以保存任务，当队列没有任务时阻塞获取任务的线程、使其进入wait状态，释放CPU资源<br>阻塞队列自带阻塞和唤醒功能，不需要额外的处理，无任务时线程池利用阻塞队列的take方法挂起，从而保证核心线程的存活，不至于一直占用CPU资源</p>
<p>10.线程池种类<br>singleThreadPool<br>只有一个核心线程，所有任务都在一个线程上顺序执行<br>任务队列使用linkedBlockingQueue<br>fixedThreadPool<br>核心线程与最大线程数一样 ，超过最大线程数会将任务放在任务队列中<br>任务队列使用linkedBlockingQueue<br>cachedThreadPool<br>核心线程数为0 最大线程数为int最大值<br>空闲线程在60s后回收，任务队列为synchonousQueue<br>scheduleThreadPool<br>核心线程数固定，支持定时或周期性执行任务,任务队列是delayBlockingQueue延迟阻塞队列<br>workStealingPool(jdk8)<br>动态线程池，内部使用forkjoinPool实现，利用分层工作窃取算法处理任务，每个工作线程维护自己的本地队列，同时可以从其他线程的队列中窃取任务，线程数根据cpu核心数调整</p>
<p>11.为什么不推荐使用内置线程池？<br>1)使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池,有可能会造成系统创建大量同类线程而导致消耗完内存或者过度上下文切换<br>2)线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor</p>
<p>12.上下文切换<br>任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>13.线程数设置<br>N是CPU核心数<br>CPU 密集型任务(N+1)<br>利用CPU 计算能力的任务比如在内存中对大量数据进行排序 复杂算法<br>I&#x2F;O 密集型任务(2N+1)<br>涉及到网络传输&#x2F;文件读取下载&#x2F;数据库交互<br>系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程</p>
<p>比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断或其它原因导致的任务暂停而带来的影响</p>
<p>14.submit和execute区别<br>1)二者所接收的参数不一样<br>Execute()方法只能接收Runnable类型的参数<br>submit()方法可以接收Callable、Runnable两种类型的参数<br>Callable允许有返回值，Runnable不允许有返回值；Runnable不允许抛出异常，Callable允许抛出异常。<br>2)submit()提交任务后会有返回值，而execute()没有<br>execute()方法主要用于启动任务的执行，任务执行后不会有返回值。<br>submit()方法也用于启动任务的执行，但是启动之后会返回Future对象<br>3)submit()方便Exception处理<br>submit()方法执行后会返回一个Future对象，我们可以通过调用Future对象的.get()方法，来判断执行是否成功（结果为null时代表成功，而失败可以catch来捕获异常，从而分析失败原因）</p>
<p>15.countdownlatch<br>可以用来模拟并发(让多个线程等待)、多线程处理数据合并结果(让主线程等待，利用join也可)<br>假设有个服务启动场景，服务启动前需要先初始化模块a b c，服务需要等待模块a b c初始化完毕才能运行</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
